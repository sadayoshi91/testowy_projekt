// electron.main.js  <- zastępuje poprzedni kod main
const { app, BrowserWindow, ipcMain } = require('electron');
const path = require('path');
const fs = require('fs');
const http = require('http');

const DEV_URL = 'http://127.0.0.1:5173';
const DEV_CHECK_RETRIES = 20;
const DEV_CHECK_INTERVAL_MS = 300;

function createWindow() {
    const preloadPath = path.join(__dirname, 'electron', 'preload.js');

    console.log('[main] __dirname =', __dirname);
    console.log('[main] preloadPath =', preloadPath, 'exists=', fs.existsSync(preloadPath));

    const win = new BrowserWindow({
        width: 1280,
        height: 800,
        webPreferences: {
            preload: preloadPath,
            contextIsolation: true,
            nodeIntegration: false
        }
    });

    // przydatne w dev: DevTools
    win.webContents.openDevTools();

    checkDevServer(DEV_URL, DEV_CHECK_RETRIES, DEV_CHECK_INTERVAL_MS)
        .then(() => {
            console.log('[main] Dev server is up, loading', DEV_URL);
            win.loadURL(DEV_URL).catch(err => {
                console.error('[main] loadURL failed', err);
                loadLocalFileOrFallback(win);
            });
        })
        .catch(() => {
            console.log('[main] Dev server not available, trying local build');
            loadLocalFileOrFallback(win);
        });
}

function loadLocalFileOrFallback(win) {
    const localFile = path.join(__dirname, 'dist', 'index.html');
    if (fs.existsSync(localFile)) {
        win.loadFile(localFile).catch(err => console.error('[main] loadFile failed', err));
    } else {
        console.warn('[main] local file not found:', localFile);
        win.loadURL('data:text/html,<h2>App not found</h2><p>No dev server and no dist/index.html</p>');
    }
}

function checkDevServer(url, retries, intervalMs) {
    return new Promise((resolve, reject) => {
        let attempts = 0;
        const tryOnce = () => {
            attempts++;
            const req = http.get(url, res => {
                if (res.statusCode && res.statusCode < 400) { res.resume(); resolve(); }
                else { res.resume(); next(); }
            });
            req.on('error', () => next());
            req.setTimeout(1000, () => { req.destroy(); next(); });
        };
        const next = () => {
            if (attempts >= retries) return reject();
            setTimeout(tryOnce, intervalMs);
        };
        tryOnce();
    });
}

/* IPC handlers */
ipcMain.handle('save-file', async (event, name, data) => {
    try {
        const saveDir = path.join(process.cwd(), 'save');
        if (!fs.existsSync(saveDir)) fs.mkdirSync(saveDir, { recursive: true });
        const filePath = path.join(saveDir, `${name}.json`);
        fs.writeFileSync(filePath, data, 'utf8');
        console.log('[main] save-file ->', filePath);
        return { path: filePath };
    } catch (err) {
        console.error('[main] save-file error', err);
        throw err;
    }
});

ipcMain.handle('load-file', async (event, name) => {
    try {
        const saveDir = path.join(process.cwd(), 'save');
        const filePath = path.join(saveDir, `${name}.json`);
        if (!fs.existsSync(filePath)) return null;
        const txt = fs.readFileSync(filePath, 'utf8');
        console.log('[main] load-file ->', filePath);
        return txt;
    } catch (err) {
        console.error('[main] load-file error', err);
        throw err;
    }
});

ipcMain.handle('list-mods', async () => {
    try {
        const modsPath = path.join(process.cwd(), 'mods');
        if (!fs.existsSync(modsPath)) return [];
        const items = fs.readdirSync(modsPath);
        const list = [];
        for (const it of items) {
            const fi = path.join(modsPath, it);
            const stat = fs.statSync(fi);
            if (stat.isDirectory()) {
                const meta = path.join(fi, 'mod.json');
                if (fs.existsSync(meta)) {
                    try { list.push(JSON.parse(fs.readFileSync(meta, 'utf8'))); } catch (e) { }
                }
            }
        }
        console.log('[main] list-mods =>', list.length, 'mods');
        return list;
    } catch (err) {
        console.error('[main] list-mods error', err);
        throw err;
    }
});

ipcMain.handle('save-payroll', async (event, payload) => {
    try {
        const saveDir = path.join(process.cwd(), 'save');
        if (!fs.existsSync(saveDir)) fs.mkdirSync(saveDir, { recursive: true });
        const fileName = `payroll-${Date.now()}.json`;
        const filePath = path.join(saveDir, fileName);
        fs.writeFileSync(filePath, JSON.stringify(payload, null, 2), 'utf8');
        console.log('[main] save-payroll ->', filePath);
        return filePath;
    } catch (err) {
        console.error('[main] save-payroll error', err);
        throw err;
    }
});

ipcMain.handle('list-saves', async () => {
    try {
        const saveDir = path.join(process.cwd(), 'save');
        if (!fs.existsSync(saveDir)) {
            return [];
        }
        const files = fs.readdirSync(saveDir).filter((file) => file.endsWith('.json'));
        const slots = files.map((file) => {
            const filePath = path.join(saveDir, file);
            const stats = fs.statSync(filePath);
            return {
                name: path.basename(file, '.json'),
                updatedAt: stats.mtimeMs,
                size: stats.size,
                path: filePath,
            };
        });
        return slots;
    } catch (err) {
        console.error('[main] list-saves error', err);
        throw err;
    }
});

app.whenReady().then(createWindow);

app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') app.quit();
});
