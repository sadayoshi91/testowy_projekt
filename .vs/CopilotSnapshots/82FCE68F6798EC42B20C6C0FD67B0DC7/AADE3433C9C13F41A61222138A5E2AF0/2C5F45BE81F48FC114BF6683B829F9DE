import React, { useEffect, useState, useRef, useReducer, useCallback } from 'react';
import { createEmptyCompany, CompanyState, getDefaultContracts, getDefaultOffices, getDefaultResearches, getDefaultCompetitors } from '../models/company';
import { TickManager } from '../simulation/TickManager';
import { HRSystem } from '../systems/HRSystem';
import { ProjectSystem } from '../systems/ProjectSystem';
import { EconomySystem } from '../systems/EconomySystem';
import { ProjectRowEnhanced } from './components/ProjectList_enhanced';
import { ProjectDetails } from './components/ProjectDetails';
import { EmployeesList } from './components/EmployeesList';
import { AssignModal } from './components/AssignModal';
import { EventLog } from './components/EventLog';
import { FinancePanel } from './components/FinancePanel';
import { Toasts, ToastItem } from './components/Toast';
import { ConfirmationModal } from './components/ConfirmationModal';
import { BankruptcyModal } from './components/BankruptcyModal';
import { ErrorBoundary } from './components/ErrorBoundary';
import { OfficeGrid } from './components/OfficeGrid';
import { listMods } from '../services/ModLoader';
import { useEconomy } from './hooks/useEconomy';
import { usePayrollHelpers } from './hooks/usePayroll';
import { Project, Role } from '../models/project';
import { ContractsPanel } from './components/ContractsPanel';
import { TrainingsPanel } from './components/TrainingsPanel';
import { Training } from '../models/training';
import { ResearchPanel } from './components/ResearchPanel';
import { Research } from '../models/research';
import type { Employee, Skills } from '../models/employee';
import { FaFileContract, FaTasks, FaUsers, FaChalkboardTeacher, FaMoneyBill, FaListAlt, FaMoon, FaSun } from 'react-icons/fa';
import { OfficePanel } from './components/OfficePanel';
import { Office } from '../models/office';
import { CompetitorsPanel } from './components/CompetitorsPanel';
import { Competitor } from '../models/competitor';
import { GameEventsPanel } from './components/GameEventsPanel';
import { StatsPanel } from './components/StatsPanel';
import { MissionsPanel } from './components/MissionsPanel';
import { MainMenu } from './components/MainMenu';
import { generateContractsBatch } from '../services/ContractGenerator';
import { OfficeMap } from './components/OfficeMap';
import { SaveManagerModal, SaveSlot } from './components/SaveManagerModal';
import './AppLayout.css';

const DEFAULT_ROLES: Role[] = ['developer', 'designer'];
const DEFAULT_STATUS = 'active';
const SAVE_VERSION = 2;
const SAVE_NAME_REGEX = /^[a-z0-9-_]{3,32}$/i;
type CompanyUpdater = (state: any) => any;
type CompanyAction =
  | { type: 'replace'; value: any }
  | { type: 'update'; updater: CompanyUpdater };

const companyReducer = (state: any, action: CompanyAction): any => {
  switch (action.type) {
    case 'replace':
      return action.value;
    case 'update':
      return action.updater(state);
    default:
      return state;
  }
};
const ROLE_SKILL_MAP: Record<Role, keyof Skills> = {
  developer: 'coding',
  designer: 'design',
  marketer: 'marketing',
  researcher: 'research',
};

type ProjectStatus = 'active' | 'completed' | 'paused';
type EmployeeLevel = 'junior' | 'mid' | 'senior';

const EMPLOYEE_FIRST_NAMES = ['Alex','Maya','Jordan','Nina','Leo','Ivy','Marcus','Sara','Kenji','Ola'];
const EMPLOYEE_LAST_NAMES = ['Nowak','Kowalski','Lee','Lopez','Singh','Chen','Khan','Novak','Smith','Ivanova'];
const ROLE_OPTIONS: Role[] = ['developer','designer','marketer','researcher'];
const LEVEL_OPTIONS: EmployeeLevel[] = ['junior','mid','senior'];
const SKILL_BY_LEVEL: Record<EmployeeLevel, number> = { junior: 50, mid: 70, senior: 90 };
const SALARY_BY_LEVEL: Record<EmployeeLevel, number> = { junior: 220, mid: 360, senior: 540 };

const pickRandom = <T,>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)];

const randomEmployeeName = () => `${pickRandom(EMPLOYEE_FIRST_NAMES)} ${pickRandom(EMPLOYEE_LAST_NAMES)}`;

type CandidateTrait = {
  key: 'focused' | 'multidisciplinary' | 'mentor' | 'sprinter';
  label: string;
  description: string;
  apply: (employee: Employee) => Employee;
};

type RecruitCandidate = {
  id: string;
  name: string;
  role: Role;
  level: EmployeeLevel;
  baseSkill: number;
  salary: number;
  hiringCost: number;
  trait: CandidateTrait;
};

const CANDIDATE_TRAITS: CandidateTrait[] = [
  {
    key: 'focused',
    label: 'Focused',
    description: '+10% productivity and +5 morale on hire.',
    apply: (employee) => ({
      ...employee,
      productivity: +(employee.productivity * 1.1).toFixed(2),
      morale: Math.min(100, (employee.morale || 0) + 5),
    }),
  },
  {
    key: 'multidisciplinary',
    label: 'Multidisciplinary',
    description: '+6 to every skill (max 100).',
    apply: (employee) => {
      const boosted: Skills = { ...employee.skills };
      (Object.keys(boosted) as (keyof Skills)[]).forEach((key) => {
        boosted[key] = Math.min(100, boosted[key] + 6);
      });
      return { ...employee, skills: boosted };
    },
  },
  {
    key: 'mentor',
    label: 'Team Mentor',
    description: '+15 morale and -10 fatigue when hired.',
    apply: (employee) => ({
      ...employee,
      morale: Math.min(100, (employee.morale || 0) + 15),
      fatigue: Math.max(0, (employee.fatigue || 0) - 10),
    }),
  },
  {
    key: 'sprinter',
    label: 'Project Sprinter',
    description: 'Starts in fast pace with +5% productivity.',
    apply: (employee) => ({
      ...employee,
      workPace: 'fast',
      productivity: +(employee.productivity * 1.05).toFixed(2),
    }),
  },
];

const CANDIDATE_POOL_SIZE = 4;
const CANDIDATE_REFRESH_COST = 750;
const CONTRACT_MANUAL_REFRESH_COST = 1500;
const CONTRACT_REFRESH_COOLDOWN_DAYS = 3;

const clampSkill = (value: number) => Math.max(35, Math.min(100, value));

const pickLevelForReputation = (reputation: number): EmployeeLevel => {
  const repFactor = Math.min(0.4, Math.max(0, reputation - 60) / 400);
  const roll = Math.random();
  if (roll > 0.75 - repFactor) return 'senior';
  if (roll > 0.35 - repFactor * 0.5) return 'mid';
  return 'junior';
};

const generateRecruitCandidate = (reputation: number): RecruitCandidate => {
  const level = pickLevelForReputation(reputation);
  const role = pickRandom(ROLE_OPTIONS);
  const trait = pickRandom(CANDIDATE_TRAITS);
  const repFactor = Math.min(0.35, Math.max(0, reputation - 80) / 400);
  const baseSkill = clampSkill(
    SKILL_BY_LEVEL[level] + Math.round((Math.random() - 0.5) * 25) + Math.round(repFactor * 20)
  );
  const salary = Math.max(
    140,
    Math.round(SALARY_BY_LEVEL[level] * (0.9 + Math.random() * 0.5 + repFactor * 0.4))
  );
  const hiringCost = Math.round(salary * (1.2 + Math.random() * 0.8));
  return {
    id: 'cand_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 5),
    name: randomEmployeeName(),
    role,
    level,
    baseSkill,
    salary,
    hiringCost,
    trait,
  };
};

const generateCandidatePool = (reputation: number, size = CANDIDATE_POOL_SIZE) =>
  Array.from({ length: size }, () => generateRecruitCandidate(reputation));

const applyTraitToEmployee = (employee: Employee, trait: CandidateTrait): Employee => {
  const cloned: Employee = {
    ...employee,
    skills: { ...employee.skills },
  };
  const modified = trait.apply(cloned);
  return {
    ...modified,
    trait: trait.label,
    traitDescription: trait.description,
  };
};

type HireOptions = {
  trait?: CandidateTrait;
  signingCost?: number;
};

const normalizeCompanyState = (state: any): CompanyState => {
  const base = createEmptyCompany();
  return {
    ...base,
    ...state,
    contracts: state?.contracts?.length ? state.contracts : getDefaultContracts(),
    offices: state?.offices?.length ? state.offices : getDefaultOffices(),
    researches: state?.researches?.length ? state.researches : getDefaultResearches(),
    competitors: state?.competitors?.length ? state.competitors : getDefaultCompetitors(),
    trainings: state?.trainings || [],
    projects: state?.projects || [],
    employees: state?.employees || [],
    events: state?.events || [],
    gameEvents: state?.gameEvents || [],
    missions: state?.missions || [],
    unlockedTechnologies: state?.unlockedTechnologies || [],
    payrollHistory: state?.payrollHistory || [],
    office: state?.office || base.office,
    selectedOfficeId: state?.selectedOfficeId ?? base.selectedOfficeId,
    reputation: state?.reputation ?? base.reputation,
    funds: state?.funds ?? base.funds,
    day: state?.day ?? base.day,
    name: state?.name ?? base.name,
    nextContractRefreshDay: state?.nextContractRefreshDay ?? base.nextContractRefreshDay,
    lastContractRefreshDay: state?.lastContractRefreshDay ?? base.lastContractRefreshDay,
  };
};

const App: React.FC = () => {
  const [company, dispatchCompany] = useReducer(companyReducer, undefined, () => createEmptyCompany());
  const setCompany = useCallback((valueOrUpdater: any) => {
    if (typeof valueOrUpdater === 'function') {
      dispatchCompany({ type: 'update', updater: valueOrUpdater as CompanyUpdater });
    } else {
      dispatchCompany({ type: 'replace', value: valueOrUpdater });
    }
  }, []);
  const [toasts, setToasts] = useState<ToastItem[]>([]);
  const [confirmProps, setConfirmProps] = useState<any>(null);
  const [bankruptOpen, setBankruptOpen] = useState(false);
  const [showAddProject, setShowAddProject] = useState(false);
  const [newProject, setNewProject] = useState({
    name: '',
    description: '',
    effort:100,
    reward:1000,
    requiredRoles: DEFAULT_ROLES,
  });
  const [editProjectId, setEditProjectId] = useState<string|null>(null);
  const [editProject, setEditProject] = useState<any>(null);
  const [filterStatus, setFilterStatus] = useState<string>('all');
  const [sortKey, setSortKey] = useState<string>('createdAt');
  const [activeTab, setActiveTab] = useState<string>('contracts');
  const [darkMode, setDarkMode] = useState(false);
  const [tickSpeed, setTickSpeed] = useState(1000); // domyślnie x1
  const [gameHour, setGameHour] = useState(8); // start od8:00
  const [gameDay, setGameDay] = useState(1);
  const [showMainMenu, setShowMainMenu] = useState(true);
  const [showPauseMenu, setShowPauseMenu] = useState(false);
  const [showOptionsOverlay, setShowOptionsOverlay] = useState(false);
  const [canContinue, setCanContinue] = useState(false);
  const [showSaveModal, setShowSaveModal] = useState(false);
  const [saveSlots, setSaveSlots] = useState<SaveSlot[]>([]);
  const [saveSlotsLoading, setSaveSlotsLoading] = useState(false);
  const [saveBusy, setSaveBusy] = useState(false);
  const [saveNameInput, setSaveNameInput] = useState('');
  const [saveNameError, setSaveNameError] = useState<string | null>(null);
  const [newHireName, setNewHireName] = useState('');
  const [newHireRole, setNewHireRole] = useState<Role>('developer');
  const [newHireLevel, setNewHireLevel] = useState<EmployeeLevel>('junior');
  const [newHireSalary, setNewHireSalary] = useState<number>(SALARY_BY_LEVEL['junior']);
  const [candidatePool, setCandidatePool] = useState<RecruitCandidate[]>([]);

  const tickManagerRef = useRef<any>(null);
  const hrRef = useRef<any>(null);
  const projectRef = useRef<any>(null);
  const econRef = useRef<any>(null);
  const lastActiveSpeedRef = useRef<number>(1000);
  const economy = useEconomy(company, setCompany); 
  const rebuildCandidatePool = useCallback((repOverride?: number) => {
    const rep = repOverride ?? company.reputation ?? 100;
    setCandidatePool(generateCandidatePool(rep));
  }, [company.reputation]);
   const getCompany = () => company;
  const { runPayroll: backupPayroll, exportPayroll: exportPayrollIPC } = usePayrollHelpers(setCompany, getCompany, (t: any) => {
        
        pushToast(t);
    });
  

  const menuTabs = [
    { key: 'contracts', label: 'Contracts', icon: <FaFileContract /> },
    { key: 'projects', label: 'Projects', icon: <FaTasks /> },
    { key: 'employees', label: 'Employees', icon: <FaUsers /> },
    { key: 'trainings', label: 'Trainings', icon: <FaChalkboardTeacher /> },
    { key: 'rnd', label: 'R&D', icon: <FaListAlt /> },
    { key: 'office', label: 'Office', icon: <FaUsers /> },
    { key: 'competitors', label: 'Competitors', icon: <FaListAlt /> },
    { key: 'events', label: 'Events', icon: <FaListAlt /> },
    { key: 'missions', label: 'Missions', icon: <FaListAlt /> },
    { key: 'stats', label: 'Stats', icon: <FaListAlt /> },
    { key: 'finance', label: 'Finance', icon: <FaMoneyBill /> },
    { key: 'log', label: 'Log', icon: <FaListAlt /> },
  ];

  if (!hrRef.current) hrRef.current = new HRSystem();
  if (!projectRef.current) projectRef.current = new ProjectSystem();
  if (!econRef.current) econRef.current = new EconomySystem(company?.payrollIntervalDays || 30);

  const pushToast = useCallback((t: Omit<ToastItem, 'id'>) => {
     const id = (Date.now()).toString(36) + Math.random().toString(36).slice(2,6);
     setToasts(s => [{ id, ...t }, ...s].slice(0, 6));
  }, []);

  const openConfirmation = (props:string) => {
    setConfirmProps(props);
  };

  useEffect(() => {
    (async () => {
      const m = await listMods();
    })();
  }, []);

  const pushEvent = (msg: string) => {
    const stamp = new Date().toLocaleTimeString();
    setCompany((c: any) => ({ ...c, events: [`${stamp} — ${msg}`, ...(c.events||[])] }));
  };

  const pushProjectEvent = (msg: string) => {
    const stamp = new Date().toLocaleTimeString();
    setCompany((c: any) => ({ ...c, events: [`${stamp} — ${msg}`, ...(c.events||[])] }));
  };

  const validateSaveName = useCallback((value: string) => {
    if (!value || !value.trim()) return 'Save name is required';
    if (!SAVE_NAME_REGEX.test(value.trim())) {
      return 'Use 3-32 letters, numbers, dash or underscore';
    }
    return null;
  }, []);

  const handleSaveNameChange = (value: string) => {
    setSaveNameInput(value);
    if (!value) {
      setSaveNameError(null);
      return;
    }
    setSaveNameError(validateSaveName(value.trim()));
  };

  const readLocalSaves = useCallback((): SaveSlot[] => {
    if (typeof window === 'undefined' || !window.localStorage) return [];
    return Object.keys(window.localStorage)
      .filter(key => key.startsWith('save_'))
      .map(key => {
        const raw = window.localStorage.getItem(key);
        let updatedAt: number | undefined;
        if (raw) {
          try {
            const parsed = JSON.parse(raw);
            if (parsed?.lastSavedAt) {
              const ts = Date.parse(parsed.lastSavedAt);
              if (!Number.isNaN(ts)) updatedAt = ts;
            }
          } catch (err) {
            console.warn('Invalid save payload', err);
          }
        }
        return { name: key.replace('save_', ''), updatedAt, size: raw?.length, source: 'local' as const };
      });
  }, []);

  const fetchSaveSlots = useCallback(async () => {
    setSaveSlotsLoading(true);
    try {
      if (window.electronAPI?.listSaves) {
        const res = await window.electronAPI.listSaves();
        if (!res?.success) throw new Error(res?.error || 'Failed to list saves');
        const slots = (res.data || []).map(slot => ({ ...slot, source: 'fs' as const }));
        setSaveSlots(slots);
      } else {
        setSaveSlots(readLocalSaves());
      }
    } catch (err: any) {
      console.error('List saves error', err);
      pushToast({ type: 'error', message: 'Failed to read save slots' });
    } finally {
      setSaveSlotsLoading(false);
    }
  }, [readLocalSaves]);
  
  // Efekty ulepszeń na produktywność/morale (w tickCallback)
  const applyOfficeEffects = (state: any) => {
 let updated = { ...state };
 (updated.offices || []).forEach((office: any) => {
 if (!office.owned) return;
 (office.desks || []).forEach((desk: any) => {
 if (!desk.assignedEmployeeId) return;
 const emp = (updated.employees || []).find((e: any) => e.id === desk.assignedEmployeeId);
 if (!emp) return;
 (desk.upgrades || []).forEach((upg: any) => {
 if (upg.effect?.productivity) emp.productivity += upg.effect.productivity;
 if (upg.effect?.morale) emp.morale += upg.effect.morale;
 });
 });
 });
 return updated;
};

  // System awansów: pracownicy zdobywają doświadczenie, mogą awansować
  function processPromotions(state: any) {
    let updated = { ...state };
    updated.employees = (updated.employees || []).map((e: any) => {
      let exp = e.experience ||0;
      exp +=1; // zdobywaj exp co tick
      let level = e.level;
      let prod = e.productivity;
      let morale = e.morale;
      let salary = e.salary;
      if (exp >=50 && level === 'junior') {
        level = 'mid'; prod +=10; morale +=5; salary +=100;
        updated.events = [`${new Date().toLocaleTimeString()} — PROMOTION: ${e.name} awansował na mid!`, ...(updated.events || [])];
      }
      if (exp >=120 && level === 'mid') {
        level = 'senior'; prod +=15; morale +=10; salary +=200;
        updated.events = [`${new Date().toLocaleTimeString()} — PROMOTION: ${e.name} awansował na senior!`, ...(updated.events || [])];
      }
      return { ...e, experience: exp, level, productivity: prod, morale, salary };
    });
    return updated;
  }

  useEffect(() => {
    if (tickManagerRef.current) {
      tickManagerRef.current.setTickRate(tickSpeed, (s:any)=> setCompany(s));
    }
  }, [tickSpeed]);

  useEffect(() => {
    if (tickSpeed > 0) {
      lastActiveSpeedRef.current = tickSpeed;
    }
  }, [tickSpeed]);
 
   // sort & filter projects
  const filteredSortedProjects = (company.projects || [])
    .filter((p: any) => filterStatus === 'all' || p.status === filterStatus)
    .sort((a: any, b: any) => {
      if (sortKey === 'name') return a.name.localeCompare(b.name);
      if (sortKey === 'status') return (a.status || '').localeCompare(b.status || '');
      if (sortKey === 'createdAt') return (a.createdAt || '').localeCompare(b.createdAt || '');
      return 0;
    });

  const filteredSortedContracts = (company.contracts || [])
    // .filter((p: any) => filterStatus === 'all' || p.status === filterStatus)
    // .sort((a: any, b: any) => {
    //   if (sortKey === 'name') return a.name.localeCompare(b.name);
    //   if (sortKey === 'status' ) return (a.status || '').localeCompare(b.status || '');
    //   if (sortKey === 'createdAt' ) return (a.createdAt || '').localeCompare(b.createdAt || '');
    //   return 0;
    // });

  const renderContractsTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Contracts</h2>
      </div>
      <ContractsPanel
        contracts={company.contracts || []}
        onAccept={handleAcceptContract}
        onRefreshOffers={handleManualContractRefresh}
        refreshCost={CONTRACT_MANUAL_REFRESH_COST}
        canRefresh={(company.funds || 0) >= CONTRACT_MANUAL_REFRESH_COST}
        darkMode={darkMode}
        currentDay={company.day || 1}
      />
    </section>
  );

  const renderProjectsTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Projects</h2>
        <button className="accent" onClick={() => setShowAddProject(true)}>Add Project</button>
      </div>
      <div>
        {filteredSortedProjects.map((project: Project) => (
          <ProjectRowEnhanced
            key={project.id}
            project={project}
            employees={company.employees || []}
            onAssignSpecific={(pid, empId) => assignToProject(pid, empId)}
            onUnassign={(pid) => unassignLastFromProject(pid)}
            onDropEmployee={(pid, empId) => assignToProject(pid, empId)}
            darkMode={darkMode}
          />
        ))}
      </div>
      {filteredSortedProjects.length === 0 && <p>No projects found</p>}
    </section>
  );

  const renderEmployeesTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Employees</h2>
      </div>
      <div style={{ border: '1px solid #ccc', borderRadius: 8, padding: 12, marginBottom: 12, background: darkMode ? '#1f1f1f' : '#fff', color: darkMode ? '#fff' : '#222' }}>
        <h3>Hire talent</h3>
        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
          <input
            type="text"
            placeholder="Name"
            value={newHireName}
            onChange={e => setNewHireName(e.target.value)}
            style={{ flex: '1 1 140px', padding: 6, borderRadius: 6, border: '1px solid #888' }}
          />
          <select
            value={newHireRole}
            onChange={e => setNewHireRole(e.target.value as Role)}
            style={{ padding: 6, borderRadius: 6 }}
          >
            {ROLE_OPTIONS.map(role => (
              <option key={role} value={role}>{role}</option>
            ))}
          </select>
          <select
            value={newHireLevel}
            onChange={e => {
              const level = e.target.value as EmployeeLevel;
              setNewHireLevel(level);
              setNewHireSalary(SALARY_BY_LEVEL[level]);
            }}
            style={{ padding: 6, borderRadius: 6 }}
          >
            {LEVEL_OPTIONS.map(level => (
              <option key={level} value={level}>{level}</option>
            ))}
          </select>
          <input
            type="number"
            min={100}
            value={newHireSalary}
            onChange={e => setNewHireSalary(Number(e.target.value))}
            style={{ width: 120, padding: 6, borderRadius: 6 }}
          />
          <button onClick={handleHireSubmit} style={{ padding: '6px 16px', borderRadius: 6, border: 'none', background: '#4caf50', color: '#fff' }}>Hire</button>
        </div>
        <small style={{ color: darkMode ? '#aaa' : '#666' }}>Salary and skill scale with level; leave name empty for a random candidate.</small>
      </div>
      <div className="recruitment-board">
        <div className="panel-header" style={{ marginBottom: 12 }}>
          <h3>Recruitment board</h3>
          <button
            onClick={handleRefreshCandidates}
            disabled={(company.funds || 0) < CANDIDATE_REFRESH_COST}
            style={{ borderRadius: 999, padding: '6px 12px' }}
            title={(company.funds || 0) < CANDIDATE_REFRESH_COST ? 'Not enough funds' : undefined}
          >
            Refresh (-{CANDIDATE_REFRESH_COST})
          </button>
        </div>
        {candidatePool.length === 0 ? (
          <div className="muted">No candidates available. Refresh to scout new talent.</div>
        ) : (
          <div className="candidate-grid">
            {candidatePool.map(candidate => {
              const canHire = (company.funds || 0) >= candidate.hiringCost;
              return (
                <div key={candidate.id} className="candidate-card">
                  <div className="candidate-card__head">
                    <div>
                      <strong>{candidate.name}</strong>
                      <div className="candidate-card__role">{candidate.role} • {candidate.level}</div>
                    </div>
                    <div style={{ fontSize: 12, opacity: 0.8 }}>Skill {candidate.baseSkill}</div>
                  </div>
                  <div className="candidate-card__meta">
                    <span>Expected salary: {candidate.salary.toLocaleString()}</span>
                    <span>Hiring cost: {candidate.hiringCost.toLocaleString()}</span>
                  </div>
                  <div className="candidate-card__trait">
                    <strong>{candidate.trait.label}</strong> — {candidate.trait.description}
                  </div>
                  <button
                    disabled={!canHire}
                    onClick={() => handleHireCandidate(candidate.id)}
                    title={!canHire ? 'Not enough funds' : undefined}
                  >
                    Hire for {candidate.hiringCost.toLocaleString()}
                  </button>
                </div>
              );
            })}
          </div>
        )}
      </div>
       <EmployeesList employees={company.employees || []} darkMode={darkMode} />
    </section>
  );

  const renderTrainingsTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Trainings</h2>
      </div>
      <ErrorBoundary>
        <TrainingsPanel trainings={company.trainings || []} employees={company.employees || []} onStart={handleStartTraining} darkMode={darkMode} />
      </ErrorBoundary>
    </section>
  );

  const renderResearchTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>R&D</h2>
      </div>
      <ResearchPanel researches={company.researches || []} onStart={handleStartResearch} onInvest={handleInvestResearch} darkMode={darkMode} />
    </section>
  );

  const renderFinanceTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Finance</h2>
      </div>
      <FinancePanel company={company} nextPayoutDays={econRef.current?.nextPayoutInDays(company)} runPayrollNow={runPayrollNow} exportPayroll={exportPayroll} updateSalary={updateSalary} openConfirmation={openConfirmation} darkMode={darkMode} />
    </section>
  );

  const renderLogTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Event Log</h2>
      </div>
      <EventLog events={(company.events || [])} darkMode={darkMode} />
    </section>
  );

  const renderCompetitorsTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Competitors</h2>
      </div>
      <CompetitorsPanel competitors={company.competitors || []} darkMode={darkMode} />
    </section>
  );

  const renderMissionsTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Missions</h2>
      </div>
      <MissionsPanel missions={company.missions || []} darkMode={darkMode} />
    </section>
  );

  const renderStatsTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Company Stats</h2>
      </div>
      <StatsPanel employees={company.employees || []} company={company} darkMode={darkMode} />
    </section>
  );

  const renderEventsTab = () => (
    <section className="panel-card">
      <div className="panel-header">
        <h2>Global Events</h2>
      </div>
      <GameEventsPanel events={company.gameEvents || []} darkMode={darkMode} />
    </section>
  );
 
   const renderOfficeTab = () => (
     <>
      <section className="panel-card">
        <div className="panel-header">
          <h2>Workspace Map</h2>
        </div>
        <OfficeMap offices={company.offices || []} employees={company.employees || []} onRent={handleRentOffice} onAssignDesk={handleAssignDesk} darkMode={darkMode} />
      </section>
      <section className="panel-card">
        <OfficePanel
          offices={company.offices || []}
          employees={company.employees || []}
          onRent={handleRentOffice}
          onAssignDesk={handleAssignDesk}
          onUpgradeDesk={handleUpgradeDesk}
          darkMode={darkMode}
        />
      </section>
    </>
  );
 
   const renderActiveTab = () => {
     switch (activeTab) {
      case 'contracts':
        return renderContractsTab();
      case 'projects':
        return renderProjectsTab();
      case 'employees':
        return renderEmployeesTab();
      case 'trainings':
        return renderTrainingsTab();
      case 'rnd':
        return renderResearchTab();
      case 'finance':
        return renderFinanceTab();
      case 'log':
        return renderLogTab();
      case 'office':
        return renderOfficeTab();
      case 'competitors':
        return renderCompetitorsTab();
      case 'events':
        return renderEventsTab();
      case 'missions':
        return renderMissionsTab();
      case 'stats':
        return renderStatsTab();
      default:
        return null;
    }
  };

  const handlePause = () => {
    setTickSpeed(0);
    tickManagerRef.current?.stop();
  };
  const handleNormal = () => {
    setTickSpeed(1000);
  };
  const handleMedium = () => {
    setTickSpeed(333);
  };
  const handleFast = () => {
    setTickSpeed(200);
  };
  const handleStart = () => {
    if (tickManagerRef.current) {
      setTickSpeed(1000); // domyślna prędkość
      tickManagerRef.current.stop();
      tickManagerRef.current.start((s: any) => {
        setCompany(s);
      });
    }
  };

  const openPauseMenu = useCallback(() => {
    if (showMainMenu || showPauseMenu) return;
    if (tickSpeed > 0) {
      lastActiveSpeedRef.current = tickSpeed;
    }
    setTickSpeed(0);
    tickManagerRef.current?.stop();
    setShowPauseMenu(true);
  }, [showMainMenu, showPauseMenu, tickSpeed])

  const resumeFromPause = useCallback(() => {
    if (!showPauseMenu) return;
    setShowPauseMenu(false);
    const resumeSpeed = lastActiveSpeedRef.current || 1000;
    setTickSpeed(resumeSpeed);
    if (tickManagerRef.current && resumeSpeed > 0) {
      tickManagerRef.current.setTickRate(resumeSpeed, (s: any) => setCompany(s));
      tickManagerRef.current.start((s: any) => setCompany(s));
    }
  }, [showPauseMenu, setCompany]);

  const handleSaveGame = async () => {
    if (typeof window === 'undefined') return;
    const saveName = window.prompt('Enter save name', 'autosave');
    if (!saveName) return;
    try {
      const payload = JSON.stringify(company);
      if (window.electronAPI?.saveFile) {
        const res = await window.electronAPI.saveFile(saveName, payload);
        if (!res?.success) throw new Error(res?.error || 'Unknown error');
        pushToast({ type: 'success', message: `Game saved: ${saveName}` });
      } else {
        localStorage.setItem(`save_${saveName}`, payload);
        pushToast({ type: 'success', message: `Game saved locally: ${saveName}` });
      }
      if (saveName === 'autosave') setCanContinue(true);
    } catch (err: any) {
      console.error('Save game error', err);
      pushToast({ type: 'error', message: `Save failed: ${err?.message || err}` });
    }
  };

  const handleLoadGame = async (presetName?: string, options?: { silent?: boolean }): Promise<boolean> => {
    if (typeof window === 'undefined') return false;
    let saveName = presetName;
    if (!saveName) {
      if (options?.silent) return false;
      const promptResult = window.prompt('Enter save name to load', 'autosave');
      if (!promptResult) return false;
      saveName = promptResult;
    }
    try {
      let data: string | null = null;
      if (window.electronAPI?.loadFile) {
        const res = await window.electronAPI.loadFile(saveName);
        if (!res?.success) throw new Error(res?.error || 'Unknown error');
        data = typeof res.data === 'string' ? res.data : null;
      } else {
        data = localStorage.getItem(`save_${saveName}`);
      }
      if (!data) throw new Error('Save not found');
      const parsed = JSON.parse(data);
      const normalized = normalizeCompanyState(parsed);
      const needsContracts = !(normalized.contracts || []).some((c: any) => c.status === 'available' || c.status === 'locked');
      const hydrated = needsContracts ? refreshContracts(normalized, true) : normalized;
      setCompany(hydrated);
      setCanContinue(true);
      rebuildCandidatePool(hydrated.reputation ?? 100);
      if (!options?.silent) {
        pushToast({ type: 'success', message: `Game loaded: ${saveName}` });
      }
      return true;
    } catch (err: any) {
      console.error('Load game error', err);
      if (!options?.silent) {
        pushToast({ type: 'error', message: `Load failed: ${err?.message || err}` });
      }
      return false;
    }
  };

  const handleDeleteSave = async (slot: SaveSlot) => {
    if (slot.source === 'local') {
      localStorage.removeItem(`save_${slot.name}`);
      pushToast({ type: 'success', message: `Save deleted: ${slot.name}` });
      fetchSaveSlots();
    } else {
      if (!window.electronAPI?.deleteSave) return;
      const res = await window.electronAPI.deleteSave(slot.name);
      if (res?.success) {
        pushToast({ type: 'success', message: `Save deleted: ${slot.name}` });
        fetchSaveSlots();
      } else {
        pushToast({ type: 'error', message: `Failed to delete save: ${res?.error || 'Unknown error'}` });
      }
    }
  };

  const handleStartNewGame = () => {
    const freshState = refreshContracts(createEmptyCompany(), true);
    setCompany(freshState);
    rebuildCandidatePool(freshState.reputation ?? 100);
    setShowMainMenu(false);
    setShowPauseMenu(false);
    setActiveTab('contracts');
    setCanContinue(false);
    pushToast({ type: 'success', message: 'New game started' });
  };

  const handleContinue = async () => {
    const success = await handleLoadGame('autosave', { silent: true });
    if (success) {
      setShowMainMenu(false);
    } else {
      pushToast({ type: 'error', message: 'Autosave not found' });
    }
  };

  const handleNewGameConfirmation = () => {
    setConfirmProps({
      open: true,
      title: 'Start new game?',
      body: 'Current progress will be lost.',
      onConfirm: () => {
        setConfirmProps(null);
        handleStartNewGame();
      },
    });
  };

 const hire = (name: string, role: Role, level: EmployeeLevel, baseSkill: number, salary: number, options?: HireOptions) => {
    const candidate = { id: 'cand_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 5), name, role, level, baseSkill, salary, hiringCost: 0, trait: undefined };
    setCompany((current) => {
      const employees = [...(current.employees || []), candidate];
      return { ...current, employees };
    });
    pushToast({ type: 'success', message: `Hired ${name} as ${role}` });
    if (options?.trait) {
      const applied = applyTraitToEmployee(candidate, options.trait);
      setCompany((current) => {
        const employees = [...(current.employees || []).filter(e => e.id !== candidate.id), applied];
        return { ...current, employees };
      });
      pushToast({ type: 'info', message: `Applied trait '${options.trait.label}' to ${name}` });
    }
  };

  const handleAcceptContract = (contractId: string) => {
    let acceptedName: string | null = null;
    setCompany((current: any) => {
      let updated = false;
      const updatedContracts = (current.contracts || []).map((c: any) => {
        if (c.id === contractId && c.status === 'available') {
          updated = true;
          acceptedName = c.name;
          return { ...c, status: 'active', employees: [], startedAt: current.day };
        }
        return c;
      });
      return updated ? { ...current, contracts: updatedContracts } : current;
    });
    if (acceptedName) {
      pushToast({ type: 'success', message: `Contract accepted: ${acceptedName}` });
    } else {
      pushToast({ type: 'error', message: 'Selected contract is no longer available' });
    }
  };

  const handleManualContractRefresh = () => {
    let refreshed = false;
    setCompany((current: any) => {
      const funds = current?.funds ?? 0;
      if (funds < CONTRACT_MANUAL_REFRESH_COST) {
        return current;
      }
      refreshed = true;
      const stateAfterPayment = {
        ...current,
        funds: +(funds - CONTRACT_MANUAL_REFRESH_COST).toFixed(2),
      };
      const refreshedState = refreshContracts(stateAfterPayment, true);
      const currentDay = current?.day || 1;
      return {
        ...refreshedState,
        lastContractRefreshDay: currentDay,
        nextContractRefreshDay: currentDay + CONTRACT_REFRESH_COOLDOWN_DAYS,
      };
    });
    pushToast(
      refreshed
        ? { type: 'success', message: 'Contract offers refreshed' }
        : { type: 'error', message: 'Not enough funds to refresh contracts' }
    );
  };

  const runPayrollNow = () => {
    backupPayroll();
    pushToast({ type: 'info', message: 'Payroll processed' });
  };

  const updateSalary = (employeeId: string, newSalary: number) => {
    setCompany((current: any) => {
      const employees = (current.employees || []).map((e: any) => {
        if (e.id === employeeId) {
          return { ...e, salary: newSalary };
        }
        return e;
      });
      return { ...current, employees };
    });
    pushToast({ type: 'success', message: 'Salary updated' });
  };

  const refreshContracts = (state: any, withLog = false) => {
    const updated = { ...state };
    const newContracts = generateContractsBatch(state);
    updated.contracts = [...(state.contracts || []).filter((c: any) => c.status !== 'active'), ...newContracts];
    if (withLog) {
      const contractNames = newContracts.map((c: any) => c.name).join(', ');
      updated.events = [`${new Date().toLocaleTimeString()} — New contracts available: ${contractNames}`, ...(state.events || [])];
    }
    return updated;
  };

  const handleRentOffice = (office: Office) => {
    setCompany((current) => {
      const offices = (current.offices || []).map((o) => {
        if (o.id === office.id) {
          return { ...o, owned: true };
        }
        return o;
      });
      return { ...current, offices };
    });
    pushToast({ type: 'success', message: `Office rented: ${office.name}` });
  };

  const handleAssignDesk = (officeId: string, deskIndex: number, employeeId: string) => {
    setCompany((current) => {
      const offices = (current.offices || []).map((o) => {
        if (o.id === officeId) {
          const desks = (o.desks || []).map((d, index) => {
            if (index === deskIndex) {
              return { ...d, assignedEmployeeId: employeeId };
            }
            return d;
          });
          return { ...o, desks };
        }
        return o;
      });
      return { ...current, offices };
    });
    pushToast({ type: 'success', message: `Assigned desk ${deskIndex + 1} in ${officeId}` });
  };

  const handleUpgradeDesk = (officeId: string, deskIndex: number) => {
    setCompany((current) => {
      const offices = (current.offices || []).map((o) => {
        if (o.id === officeId) {
          const desks = (o.desks || []).map((d, index) => {
            if (index === deskIndex) {
              return { ...d, upgraded: true };
            }
            return d;
          });
          return { ...o, desks };
        }
        return o;
      });
      return { ...current, offices };
    });
    pushToast({ type: 'success', message: `Upgraded desk ${deskIndex + 1} in ${officeId}` });
  };

  const assignToProject = (projectId:string, employeeId?:string) => {
    setCompany((current) => {
      const projects = (current.projects || []).map((p) => {
        if (p.id === projectId) {
          if (!employeeId) {
            // unassign last employee
            const lastEmployeeId = p.employees?.[p.employees.length - 1];
            if (lastEmployeeId) {
              const desks = (current.offices || []).flatMap((o) => o.desks || []);
              const deskToFree = desks.find(d => d.assignedEmployeeId === lastEmployeeId);
              if (deskToFree) {
                deskToFree.assignedEmployeeId = undefined;
                pushToast({ type: 'info', message: `Unassigned ${lastEmployeeId} from project ${projectId}` });
              }
            }
            return { ...p, employees: p.employees?.slice(0, p.employees.length - 1) };
          }
          return { ...p, employees: [...(p.employees || []), employeeId] };
        }
        return p;
      });
      return { ...current, projects };
    });
    pushToast({ type: 'success', message: `Assigned employee to project ${projectId}` });
  };

  const unassignLastFromProject = (projectId:string) => {
    setCompany((current) => {
      const projects = (current.projects || []).map((p) => {
        if (p.id === projectId) {
          const lastEmployeeId = p.employees?.[p.employees.length - 1];
          if (lastEmployeeId) {
            const desks = (current.offices || []).flatMap((o) => o.desks || []);
            const deskToFree = desks.find(d => d.assignedEmployeeId === lastEmployeeId);
            if (deskToFree) {
              deskToFree.assignedEmployeeId = undefined;
              pushToast({ type: 'info', message: `Unassigned ${lastEmployeeId} from project ${projectId}` });
            }
          }
          return { ...p, employees: p.employees?.slice(0, p.employees.length - 1) };
        }
        return p;
      });
      return { ...current, projects };
    });
    pushToast({ type: 'success', message: `Unassigned last employee from project ${projectId}` });
  };

  return (
    <div className={`app-container ${darkMode ? 'dark' : ''}`}>
      <div className="app-header">
        <div className="header-inner">
          <h1>{company.name || 'Untitled Company'}</h1>
          <div className="header-actions">
            <button className="menu-button" onClick={() => setShowMainMenu(true)}>
              <FaListAlt />
            </button>
            <button className="dark-mode-toggle" onClick={() => setDarkMode(dm => !dm)}>
              {darkMode ? <FaSun /> : <FaMoon />}
            </button>
          </div>
        </div>
      </div>
      <div className="app-content">
        <div className="tabs">
          {menuTabs.map(tab => (
            <div
              key={tab.key}
              className={`tab ${activeTab === tab.key ? 'active' : ''}`}
              onClick={() => setActiveTab(tab.key)}
            >
              {tab.icon}
              <span>{tab.label}</span>
            </div>
          ))}
        </div>
        <div className="tab-content">
          {renderActiveTab()}
        </div>
      </div>
      <div className="app-footer">
        <div className="footer-inner">
          <span>Day {company.day || 1} - </span>
          <span>Funds: ${company.funds?.toFixed(2) || '0.00'} - </span>
          <span>Reputation: {company.reputation || 0}</span>
        </div>
      </div>
      {showMainMenu && (
        <MainMenu
          canContinue={canContinue}
          onNewGame={handleNewGameConfirmation}
          onContinue={handleContinue}
          onLoadGame={async () => {
            const success = await handleLoadGame();
            if (success) setShowMainMenu(false);
          }}
          onToggleOptions={() => setShowOptionsOverlay(true)}
          onExit={() => {
            if (typeof window !== 'undefined') {
              window.location.reload();
            }
          }}
          onClose={() => setShowMainMenu(false)}
          darkMode={darkMode}
        />
      )}
      {showPauseMenu && (
        <div className="pause-menu">
          <div className="pause-menu-inner">
            <h2>Game Paused</h2>
            <button onClick={resumeFromPause}>Resume</button>
            <button onClick={handleSaveGame}>Save Game</button>
            <button onClick={handleLoadGame}>Load Game</button>
            <button onClick={handleNewGameConfirmation}>New Game</button>
            <button onClick={() => setShowPauseMenu(false)}>Options</button>
            <button onClick={() => setShowMainMenu(true)}>Main Menu</button>
          </div>
        </div>
      )}
      {showOptionsOverlay && (
        <div className="options-overlay">
          <div className="options-inner">
            <h2>Options</h2>
            <label>
              Tick Speed:
              <input
                type="range"
                min={100}
                max={5000}
                step={100}
                value={tickSpeed}
                onChange={e => setTickSpeed(Number(e.target.value))}
              />
            </label>
            <label>
              Dark Mode:
              <input
                type="checkbox"
                checked={darkMode}
                onChange={() => setDarkMode(dm => !dm)}
              />
            </label>
            <button onClick={() => setShowOptionsOverlay(false)}>Close</button>
          </div>
        </div>
      )}
      {confirmProps && (
        <ConfirmationModal
          {...confirmProps}
          onConfirm={confirmProps.onConfirm}
          onCancel={() => setConfirmProps(null)}
        />
      )}
      {bankruptOpen && (
        <BankruptcyModal
          onClose={() => setBankruptOpen(false)}
          onConfirm={() => {
            setBankruptOpen(false);
            // Handle bankruptcy confirmation (e.g., reset game, load preset, etc.)
          }}
        />
      )}
      <Toasts toasts={toasts} onRemove={id => setToasts(t => t.filter(tt => tt.id !== id))} />
    </div>
  );
};

export default App;
